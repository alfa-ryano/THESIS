\chapter{Literature Review}
This work has conducted a literature review and existing tool exploration to 
identify problem that provide motivation for research. 

\section{Identifying Changes in Models}
\label{sec:identifying_changes_in models}
There are two approaches in the literature for identifying changes in models 
in order to enable incremental re-execution of model processing operations.

\textbf{Notifications}. In this approach, the incremental execution 
engine needs to hook into the notification facilities 
provided by the modelling tool through which the developer edits the model, 
so that the engine can directly receive notifications as soon as 
changes happen (e.g. a new employee (\emph{e4}) has been added, 
the name property of employee \emph{e4} has been changed to ``Richmond"). 
This is an approach taken by the IncQuery incremental pattern matching 
framework \cite{DBLP:conf/ecmdafa/RathHV12} and the ReactiveATL incremental model-to-model 
transformation engine \cite{DBLP:conf/ecmdafa/OgunyomiRK15}. The main advantage of this 
approach is that precise and fine-grained change notifications are provided 
for free by the modelling tool (and thus do not need to be computed by the 
execution engine---which as discussed below can be expensive and inefficient). 
On the downside, this approach is a poor fit for collaborative development 
settings where modelling and automated model processing activities are 
performed by different members of the team.

\textbf{Model Differencing}. This approach eliminates the coupling between 
modelling tools and incremental execution engines. Instead of depending on 
live notifications, in this approach the developer in charge of automated model 
processing, needs to have access to a copy of the last version of the model that 
the model processing program (e.g. the model-to-text transformation) was 
executed upon, so that it can be compared against the current version of 
the model (e.g. using a model-differencing framework such as SiDiff or 
EMFCompare) and the delta can be computed on demand. The main advantage of 
this approach is that it works well in a collaborative development environment 
where typically developers have distinct roles and responsibilities. On the 
downside, model comparison and differencing are computationally expensive and 
memory-greedy (both versions of the model need to be loaded into memory before 
they can be compared), thus largely undermining the time and resource saving 
potentials of incremental re-execution. This approach is adopted by the Xpand 
model-to-text transformation language. According to the developers of the 
language, using this approach, a speed-up of only around 50\% is observed 
compared to non-incremental transformation\footnote{\url{http://wiki.eclipse.org/Xpand/
        New_And_Noteworthy\#Incremental_Generation}}, 
which is consistent with our experience from using Xpand.

In summary, incremental model processing currently delivers significant 
performance benefits only in a single-developer environment where the modeller 
is also responsible for performing all the (incremental) model processing 
operations. As a result, in collaborative development environments, 
developers need to either forgo incremental model processing altogether 
or to work around this limitation by manually steering model processing 
programs to process only subsets of their models, which is cumbersome and 
error prone.


\section{State-based Persistence vs. Change-based Persistence}
\label{sec:state-based_model_vs_change-based_model}

The concept of change-based persistence is not new and has been used in persisting changes to software, 
object-oriented databases, and hierarchical documents 
\cite{DBLP:journals/entcs/RobbesL07,DBLP:conf/sde/LippeO92,DBLP:conf/caise/IgnatN05}. 
The change-based approach can improve detecting differences more precisely at the semantic 
level -- that is by providing finer-granularity information (e.g. types of changes, the order of the changes, 
elements that were changed, previous values, etc.) -- and therefore provide support to resolve them \cite{mens2002state}. 
The ordered nature of change-based persistence means that changes made to a model can be identified sequentially without 
having to explore and compare all elements of the model and its previous version. Based on these arguments, 
this work explores the advantages and shortcomings of change-based persistence as an alternative approach to 
state-based persistence for models conforming to 3-layer metamodelling architectures such as EMF and MOF. 
Persisting models in a change-based format can bring a number of envisioned benefits over state-based persistence, 
such as the ability to detect changes much faster and more precisely, which can then have positive 
knock-on effects on supporting (1) developers compare and merge models in collaborative modelling environments, 
and (2) incremental model management ( e.g. incremental query \cite{DBLP:conf/ecmdafa/RathHV12} and 
model-to-text transformation \cite{DBLP:conf/ecmdafa/OgunyomiRK15}). 

Nevertheless, change-based persistence also comes with downsides, such as ever-growing model files 
\cite{DBLP:journals/entcs/RobbesL07,DBLP:conf/edoc/KoegelHLHD10} and increased model loading time \cite{mens2002state}
which increase storage and computation costs. A model that is frequently modified will increase considerably in file size 
since every change is added to the file. The increased file size (proportional to the number of persisted changes) will, 
in turn, increase the loading time of the model since all changes have to be replayed to reconstruct the model's 
eventual state. These downsides have to be mitigated to enable the practical adoption of change-based persistence. 
One approach to reducing the file size of change-based models is by removing changes that do not affect the eventual 
state of the model. For the increased loading time, it can be mitigated by ignoring -- i.e. not replaying -- changes 
that are cancelled out by later changes or employing change-based and state-based persistence side-by-side so that the
benefits of state-based persistence on loading time can be obtained. Other downsides are change-based persistence requires 
integration with existing tools -- since it is still a non-standard approach -- for its adoption \cite{koegel2010emfstore}, 
and still has limited support for standard, text-based version controls for collaborative development \cite{koegel2010emfstore}. 
These downsides can be addressed by developing a change-based persistence plugin for a specific development environment 
(e.g. Eclipse) and persisting changes in text-based format to support text-based version controls (e.g. Git, SVN).

The summary of 
the literature review and existing tool exploration is presented in
Table \ref{table:summary_literature_review}.

\begin{table}[t!]
    \centering
    \caption{Summary of this work's literature review on change-based approach.}
    \label{table:summary_literature_review}
    \begin{tabular}
        {|>{\centering\arraybackslash}p{2cm}|>{\centering\arraybackslash}p{1.6cm}|>{\centering\arraybackslash}p{4.7cm}|>{\centering\arraybackslash}p{4.7cm}|}
        \hline 
        \multicolumn{2}{|c|}{\textbf{Dimensions}}&\textbf{Change-based Approach}&\textbf{State-based Approach}\\
        \hline 
        \multirow{2}{2cm}{\centering Model change-detection} & methods & use notification to capture changes & compute differences between two models \\
        \hhline{~---}
        & products & used in many incremental projects (e.g IncQuery \cite{rath2012derived}, ReactiveATL \cite{ogunyomi2015property}) & SiDiff \cite{kelter2005generic}, EMF Compare \cite{eclipse2017compare}  \\ 
        \hline
        \multirow{2}{2cm}{\centering Model persistence} & methods & persist changes of models & persist states of models \\
        \hhline{~---}
        & products & EMFStore \cite{koegel2010emfstore} & XMI, NeoEMF \cite{daniel2016neoemf}, Morsa \cite{pagan2011morsa}, CDO \cite{eclipse2017cdo}, Teneo \cite{eclipse2017teneo}\\
        \hline
        \multirow{2}{2cm}{\centering Other persistence} & entities & software \cite{DBLP:journals/entcs/RobbesL07}, database \cite{DBLP:conf/sde/LippeO92}, hierarchical documents \cite{DBLP:conf/caise/IgnatN05}, model repository and version control \cite{koegel2010emfstore} & default for most persistence entities \\
        \hline
        \multicolumn{2}{|p{3.6cm}|}{\centering Advantages} &
        \begin{minipage}[t]{4.7cm}
            \raggedright
            \begin{itemize}[leftmargin=9pt]
                \setlength\itemsep{-5pt}
                \item[-] Faster for detecting changes \cite{DBLP:conf/edoc/KoegelHLHD10}
                \item[-] More accurate, carry semantic information \cite{DBLP:journals/entcs/RobbesL07,DBLP:conf/sde/LippeO92,DBLP:conf/caise/IgnatN05,mens2002state}  
                \item[-] Faster and more accurate for comparison and merging \cite{DBLP:conf/sde/LippeO92,DBLP:conf/caise/IgnatN05,koegel2010emfstore}
                \item[-] Information carried is useful for analytics \cite{DBLP:journals/entcs/RobbesL07}
            \end{itemize}
        \end{minipage}
        & 
        \begin{minipage}[t]{4.7cm}
            \raggedright
            \begin{itemize}[leftmargin=9pt]
                \setlength\itemsep{-5pt}
                \item[-] Faster for loading large models \cite{pagan2011morsa,daniel2016neoemf}
                \item[-] Supported by standard version controls (e.g. GitHub) \cite{koegel2010emfstore} 
                \item[-] A default standard, no need integration with existing tools \cite{koegel2010emfstore}  
            \end{itemize}
        \end{minipage}
        \\
        \hline
        \multicolumn{2}{|p{3.6cm}|}{\centering Disadvantages} & \begin{minipage}[t]{4.7cm}
            \raggedright
            \begin{itemize}[leftmargin=9pt]
                \setlength\itemsep{-5pt}
                \item[-] Increased record size \cite{DBLP:journals/entcs/RobbesL07,DBLP:conf/edoc/KoegelHLHD10}
                \item[-] Is not efficient for replaying (loading) for long records \cite{mens2002state}
                \item[-] Limited supports for standard, text-based version controls (e.g. GitHub) \cite{koegel2010emfstore} 
                \item[-] Not a standard, need integration with existing tools \cite{koegel2010emfstore} 
            \end{itemize}
        \end{minipage}
        & 
        \begin{minipage}[t]{4.7cm}
            \raggedright
            \begin{itemize}[leftmargin=9pt]
                \setlength\itemsep{-5pt}
                \item[-] Slower for saving changes  (currently NoSQL is used to solve this) \cite{mens2002state,daniel2016neoemf,pagan2011morsa}
                \item[-] Slower for comparison \cite{DBLP:conf/edoc/KoegelHLHD10}
                \item[-] Less accurate, does not carry semantic information \cite{mens2002state,DBLP:conf/edoc/KoegelHLHD10}  
            \end{itemize}
        \end{minipage}
        \\
        \hline
    \end{tabular} 
\end{table}

\section{Model Persistence}
\label{model_persistence}
There are several non-XMI approaches to state-based model persistence, using relational or NoSQL databases. For example, EMF Teneo \cite{eclipse2017teneo} persists EMF models in relational databases, while Morsa \cite{DBLP:conf/models/Espinazo-PaganCM11} and NeoEMF \cite{daniel2016neoemf} persist models in document and graph databases, respectively. None of these approaches provides built-in support for versioning and models are eventually stored in binary files/folders which are known to be a poor fit for text-oriented version control systems like Git and SVN. Connected Data Objects (CDO) \cite{eclipse2017cdo}, which provides support for database-backed model persistence, also provides collaboration facilities, but CDO adoption necessitates the use of a separate version control system (e.g. a Git repository for code and a CDO repository for models), which introduces fragmentation and administration challenges \cite{barmpis2014evaluation}. Similar challenges arise in relation to other model-specific version control systems such as EMFStore \cite{koegel2010emfstore}.

We are not aware of any other work that targets comparison and diffing of change-based models persisted as files. However, there are several existing tools for state-based model comparison. Beyond EMFCompare, which we used for our comparative evaluation due to its maturity and ongoing development activity, tools such as SiDiff \cite{Treude2007SiDiff} and DSMDiff \cite{lin2009dsmdiff} also provide language-agnostic graph-based model comparison, with some room for configuration (e.g., assigning different weights to features of types in the language). Additional expressive power -- at the cost of increased complexity and configuration effort -- is offered by dedicated comparison languages such as the Epsilon Comparison Language, which can be used to compare both homogeneous and heterogeneous models \cite{kolovos2009ecl}. We refrain from a more detailed discussion on state-based comparison tools as they all require upfront loading of both versions of the model into memory, which is the main cost that we aspire to reduce with the presented change-based approach.

Database-backed model persistence and version control solutions such as CDO \cite{eclipse2019cdo} and EMFStore \cite{koegel2010emfstore} also provide diffing capabilities between different versions of the same model without requiring models to be fully loaded into memory, however they present integration challenges with mainstream software engineering tools (e.g., continuous integration systems, backup and restore facilities) which are typically file-based, and their performance can degrade as more models/users are added to a repository, since all models are effectively stored in a single database \cite{KolovosRMPGCLRV13}.


\section{State-based Model Differencing}
\label{sec:state-based_model_differencing}


\section{Model Conflict Detection}
\label{sec:model_conflict_detection}

\subsection{State-based Conflict Detection: EMF Compare}
\label{sec:emfcompare_conflict_detection}

\subsection{Change-based Conflict Detection: EMF Store}
\label{sec:emfstore_l_conflict_detection}



