\chapter{Conclusions and Future Work}
\label{ch:conclusions_and_future_work}

This chapter summarises the research that we have conducted as well as the results gained from the evaluation. It starts with conclusions that answer the research requestions and hypothesis proposed in Section \ref{sec:research_questions}. It then presents the limitations and threats to the validity of this research and some topics for future work. Lastly, this chapter presents the big picture of this research's contribution to other parts of model-driven engineering, such as model transformation, validation, and evolution. 

\section{Conclusions}
\label{conclusions_overall}
\begin{enumerate} 
  \item \textbf{How can models be persisted in a change-based format, and how does change-based persistence perform, compared to state-based persistence on loading and saving models? (RQ1)} 
  
  This research question is addressed in Chapters \ref{ch:change_based_model_persistence}, \ref{ch:optimised_loading}, and \ref{ch:hybrid_model_persistence}. In order to persist models in change-based format, a prototype has been developed. It captures relevant notifications produced by the notification facilities provided by EMF every time a change is applied to an EMF model. It then transforms the notifications into different classes of change events representing different types of changes (e.g., set, unset, add, remove, move, create, and delete) that conform to the model and metamodel infrastructure of EMF. Every captured change event is then persisted by appending it into an XML-like-formatted file when the model is saved. The model can be (re)loaded by de-serialising the file and (re)executing all the persisted change events -- replaying the historical construction of the model.
  
  Since change-based models come with a drawback that their changes have to be replayed in order to load them, this work has investigated two approaches to improve the loading. The first approach optimises loading by ignoring replaying change events that are superseded by subsequent change events. This approach employs a tree-based data structure that tracks all changes made to a model and calculates all superseded events identified by their line numbers. These line numbers are also persisted into another file -- \textsf{ignoreList} file -- when the model is saved. So, once the change-based model is reloaded, the loading algorithm already knows which change events -- which line numbers -- should be skipped. This approach can reduce significantly the loading time of change-based models compared to the non-optimised loading. However, it is still greatly outperformed by loading of models from their state-based persistence and suffers greatly on memory footprint because of the dedicated data structure employed to track change events. 
  
  In contrast, saving models in change-based persistence shows more favourable results compared to saving models in state-based persistence since we only need to persist recent changes applied to a model rather than saving the entire model. This is very favourable when working with large models at a mature stage where only small changes occur. 
  
  Since the results of the first approach are not satisfying, this work also proposed hybrid model persistence -- employing change and state-based persistence side-by-side. In this type of persistence, models are loaded from their state-based persistence but changes are persisted into both change and state-based persistence.  
  
  In the evaluation, the effects of hybrid model persistence were compared against state-based persistence on loading and saving models in terms of time and memory footprint. The results show that, almost all cases experience a slight slowdown on loading and saving time (hybrid approach's $mean$ $>$ state-based approach's $mean$). However, almost for all hybrid NeoEMF cases, the slowdown is not significant. 
  
  The hybrid approach also produces more memory footprint compared to the state-based-only approach. In terms of storage space usage, in average, persisting one change event only consumes around 100 bytes. This can be used to estimate the growth of storage space usage. For example, persisting 100 million change events consumes around 10 GBs.  
  
  \item \textbf{In a changed-based format, how can differences between models be identified, and how does change-based model differencing perform, in terms of speed and memory footprint, compared to state-based model differencing? (RQ2)}
  
 This research question is addressed in Chapter \ref{ch:model_differencing}.  Change-based persistence can be used to identify differences between two versions of a model. The change-based representation of the two versions contains all the necessary information to identify elements that have been modified since their last shared version. In this way, we can localise model differencing only to the elements that have been recently modified. In other words, not all elements are necessary to be inspected, matched, and diffed. We can use the information to reconstruct the partial states of the two versions and then compare their elements and features using specific rules to identify their differences.  
 
 The change-based model differencing proposed in this research consists of three phases: event loading, element tree construction, and diff computation. In the event loading phase, the implementation loads change events recorded in two change-based model persistence files into memory starting from the line their change events are different. The information that the loaded change events contains are used to construct an element tree. An element tree essentially is the partial states -- only the affected elements and features -- of the two versions being compared including the shared original version. It is possible to construct such a partial representation since change events are designed to contain adequate information to construct the element tree. A diff computation is then executed to identify the differences using a set of predefined rules (i.e., if an element is created in one of the versions it means that the element does not exist in the other version or in the original version).
 
 The evaluation results suggest that the proposed change-based model differencing executes faster than traditional, state-based model differencing.
 However, the change-based model differencing needs to load change events from a change-based persistence into main memory and thus can require more memory than for state-based model differencing. In our evaluation, this occurs when the number of change events exceeds 400,000. Arguably, diff and merge operations are usually performed on smaller deltas than this work's evaluation.
  
  \item \textbf{Following change-based model differencing, how can conflicts be detected between versions of a model, and  how does change-based conflict detection perform, in terms of speed and memory, compared to state-based model conflict detection? (RQ3)} 
  
  This research question is addressed in Chapter \ref{ch:conflict_detection}.  Similar to change-based model differencing in the previous research question (RQ2), this work also has proposed an approach to model conflict detection by exploiting the nature of change-based persistence which allows us to detect conflict between two versions of a model only by comparing the eventual states of elements and features of the two versions, including their shared original version, that are affected by change events.
  
  The phases in the change-based conflict detection are similar to the phases (event loading, element tree construction, and diff computation) in the change-based model differencing except that the diff computation is replaced with conflict computation. It also consists of a set of rules that compare the eventual states of the elements and features in the element tree as well as the number of change events that affects them in both versions. As an example, a feature that is modified only in one version cannot have conflicts. A conflict only occurs if the feature is modified on both versions. Also since the element tree also records every change event to the elements of features that it affect, we can trace change events that cause a conflict.
  
Based on the findings in the conflict detection evaluation, this work found that the proposed change-based model conflict detection approach outperforms the conflict detection approaches in EMF Compare and EMF Store. Nevertheless, models that have been excessively modified or experience significant reduction on model size could impair the performance of the conflict detection as a great number of change records have to be read and loaded into memory.
  
\end{enumerate}

Based on the answers of the three research questions, this work can finally confirms the hypothesis that, 
\textbf{``a textual change-based model persistence approach can outperform existing model persistence formats in terms of model saving, model differencing and conflict detection time, with an overhead in terms of model loading time and memory use''}. However, this work is not free from limitations and threats to validity. These are presented in Section \ref{sec:limitation_and_Threat_to_validity}.

\section{Limitations and Validity}
\label{sec:limitation_and_Threat_to_validity}
This work has only tested the proposed algorithms on synthesised models which were reversed engineered from two real-world software projects Epsilon \cite{eclipse2018epsilongit} and BPMN2 \cite{eclipse2018bpmn2git}, and a collaboratively developed artefact with a long development history, the article of US on Wikipedia \cite{wikipedia2018us}. The generated models may not be representative of the complexity and interconnectedness of models in other domains. Diverse characteristics of models in different domains can affect the effectiveness of the algorithms and therefore yield different outcomes. Moreover, the generated models from the reverse engineering are limited to the UML2 \cite{eclipse2017uml2}, Modisco Java \cite{eclipse2018modiscojava}, and Modisco XML \cite{eclipse2018modiscoxml} metamodels only. Thus, there is no guarantee the algorithms will perform in a consistent manner on models conforming to different metamodels.

Specifically in Chapter \ref{ch:optimised_loading}, the proposed loading optimisation of change-based model persistence only supports ordered and unique features. Support for duplicate values means that removal of an item does not necessarily result in the item not being present in the feature value. Additional information must be captured to persist the number of copies and positions of the feature members to properly generate the ignore list. 

For the proposed change-based model differencing and conflict detection in Chapters \ref{ch:model_differencing} and \ref{ch:conflict_detection}, this work has tried to cover as many as the common changes made in EMF models (e.g. performing \textsf{add}/\textsf{remove}/\textsf{set}/\textsf{move} operations on \textsf{single}/\textsf{multi}-\textsf{valued} features, \textsf{attribute}/\textsf{reference} features, or \textsf{containment}/\textsf{non}-\textsf{containment} references), but the random modification made in the evaluation many not largely reflect the evolution of models in the real world. This is challenging as different domains can have their own patterns of model evolution -- different problems, metamodels, modellers, etc. So far, the most complex composite changes applied to the random modification are limited to \textsf{move} and \textsf{delete} changes only (\textsf{move} event consists of \textsf{remove} and {add} events, while \textsf{delete} event also removes the sub-elements of the deleted element). More complex composite changes, such as refactoring, have not been evaluated. Also, the random modification does not consider the correctness of the changes since it might validate certain constraints of the models. For example, in Java \cite{eclipse2018modiscojava} models, removing a parameter from a function causes errors in the function's body, but it is ignored in the evaluation.  

\section{Future Work}
\label{future_work}
The proposed change-based model persistence also comes with a number of challenges for future work, such as loading overhead and fast-growing model files. The loading overhead has been addressed in this work by introducing hybrid model persistence -- using state and change-based persistence side-by-side -- in which models are loaded from its state-based persistence. Nevertheless, the proposed approach still requires to load change events in order to construct an \textsf{elementTree} -- Section \ref{sec:tree_construction} -- to perform model differencing and conflict detection, as discussed in Chapters \ref{ch:model_differencing} and \ref{ch:conflict_detection}. The loading can be further optimised to consume less memory and speed up parsingby using a binary or a more compact text format.

The fast-growing model files challenge has not been addressed in this work. Persisting models in a change-based format means that model files will keep growing in size during their evolution significantly faster than their state-based counterparts. Two approaches can be explored in the future to address the issue: (1) sound change-compression operations (e.g. remove older/unused information) that can be used to reduce the size of a model in a controlled way, (2) a compact textual format that will minimise the amount of space required to record a change (a textual line-separated format is desirable to maintain compatibility with file-based version control systems). 

The information contained in change-based model persistence is also useful for model analytics. With appropriate tool support, modellers will be able to ``replay" (part of) the change history of a model (e.g. to understand design decisions made by other developers, for training purposes). In state-based approaches, this can be partly achieved if models are stored in a version-control repository (e.g. Git). However, the granularity would only be at the commit level. By analysing models serialised in the proposed representation, modelling language and tool vendors will be able to develop deeper insights into how modellers actually use these languages/tools in practice and utilise this information to guide the evolution of the language/tool. By attaching additional information to each session (e.g. the id of the developer, references to external documents/URLs), sequences of changes can be traced back to the developer that made them, or to requirements/bug reports that triggered them.

\section{The Big Picture}
\label{sec:the_big_picture}

Model persistence, differencing, and conflict detection are parts of the big picture of Model-Driven Engineering. Regarding model persistence, one might consider in what scenarios change-based model persistence is preferable to state-based model persistence and \emph{vice versa}.

As our findings suggest, change-based persistence can deliver faster model differencing and conflict detection compared to state-based persistence. This benefit is achieved in the scenario when sizes of models are large and the number of changes applied is relatively moderate compared to the sizes of models. Thus, it is best to use change-based persistence in the latter stages of model development when sizes of models are already large, and changes are mostly for fine-tuning \cite{selic2003pragmatics}. In this way, storage overhead, due to the growing size of change-based files, can be minimised. 

Change-based persistence can become unacceptable in scenarios where the number of changes is excessive relative to the sizes of models. The overhead loading and processing them to construct partial states of models can make the process slower than performing state-based model differencing or conflict detection. This happens in the early stages of model development when sizes of models are still small, and changes can be numerous and radical. At these stages, state-based persistence is preferable.

The presence of change-based persistence can benefit incremental model management, such as incremental model validation and transformation. Recent changes of models can be efficiently identified without having to perform a state-based comparison to identify the differences between the current and last version of a model. In this way, we can localise model validation and transformation only to elements and features that have changed since the last version. Moreover, the produced change-based model persistence implementation conforms to the standard EMF interfaces and as such change-based models are readable/writable by EMF-compliant transformation and validation languages and engines such as ETL, EVL, OCL and ATL.

While change-based persistence is intended to record changes of models, as a model grows, its metamodel might experience some modifications too. How does change-based persistence handle changes at the metamodel level? For now, we have not addressed this challenge in our implementation. However, one solution that we can give to address this challenge is by introducing a new type of change event -- as an addition to the existing types of change events (e.g., add, move, set, create, add, etc.) -- that indicates an upgrade/downgrade of the metamodel of a model. Another solution is to add the version id of the metamodel into every change event. In this way, when loading (replaying) the change events of a model, we know that we need to do some adjustment to handle the model accordingly to the active metamodel.

In terms of generality, one might ask, ``can change-based model persistence, differencing, and conflict detection be applied to any modelling languages?'' As long as the modelling languages conform to the EMF metamodelling architecture, then they can be applied. Nevertheless, there is no support for constraints and composite changes that are specific to a modelling language, which is naturally the future work of this research. One way to do this is by using custom adapters.

For composite changes, such as refactoring, the proposed approach also supports composite change events. This feature allows multiple changes that are part of a single refactoring activity can be put into one composite change event. Thus, a change event that conflicts with a member of a composite change event also is also in conflict with the other members of the composite change event.

Still related to the generality of the solutions proposed in this research, another question to answer is ``can the proposed change based persistence, model differencing, and conflict detection be applied to other artefacts besides models (e.g., XML documents, spreadsheets)?'' As long as we can capture all the necessary changes to reconstruct an artefact then it is possible. Some editors/tools already provide dedicated SDK tools to add custom functionalities. Commonly, they provide access to some kind of event listener which captures every event executed in the editors/tools. This functionality can be used to capture changes. Also, the format of the persisted changes also needs to be adapted so that the persisted changes contain adequate information to reconstruct the partial states of the artefact. Once the partial states has been constructed, we can perform comparison between the elements of the partial states of the artefact.