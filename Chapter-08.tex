\chapter{Conclusions and Future Work}
\label{ch:conclusions_and_future_work}

This chapter summarises the work that has been performed and the evaluation results obtained in order to answer the research requestions and hypothesis proposed in Section \ref{sec:research_questions}. However, the conclusions also come with limitations and threat to validity which are also presented here. Lastly, this chapter also presents the future work that can be done to address the limitations of this work, to extend the features of the proposed change-based model persistence, or for other research topics.

\section{Conclusions}
\label{conclusions_overall}
\begin{enumerate} 
  \item \textbf{How to persist models in a change-based format? How does it perform compared to state-based persistence on loading and saving models? (RQ1)} 
  
  This research question is addressed in Chapters \ref{ch:change_based_model_persistence}, \ref{ch:optimised_loading}, and \ref{ch:hybrid_model_persistence}. In order to persist models in change-based format, this work captures changes applied to models using the notification facility provided by the EMF framework; an event-listener-like feature that produces notification every time a model is modified. Every relevant change event (set, unset, add, remove, move, create, and delete) is captured and then persisted (appended) to a file when saving operation is performed. The change events are persisted in the XML-like format in order simplify loading and saving them using existing XML library. 
  
  Since change-based models come with a drawback that their changes have to be replayed in order to load them, this work has investigated two approaches to optimise the loading. The first approach is loading optimisation by ignoring replaying change events that superseded by their subsequent change events. This approach employs a tree-based data structure that tracks all changes made to a model and calculates all superseded events identified by their line numbers. These line numbers are also persisted into another file -- \textsf{ignoreList} file -- when the model is saved. So, once the change-based model is reloaded, the loading already knew which change events -- which line numbers -- should be skipped. This approach can reduce significantly the loading time of change-based models compared to the non-optimised loading. However, it is still greatly outperformed by the loading of models from their state-based persistence and suffers greatly on memory footprint because of the dedicated data structure employed to track change events. 
  
  In contrast, saving models in change-based persistence shows more favourable results compared to saving models in state-based persistence since we only need to persist recent changes applied to a model rather than saving the entire model. This is very favourable when we work with large models in their mature stage where only small changes occur. 
  
  Since the results of the first approach are not satisfying, this work also proposed hybrid model persistence -- employing change and state-based persistence side-by-side. In this type of persistence, models are loaded from their state-based persistence but changes are persisted into both change and state-based persistence.  
  
  In the evaluation, the effects of hybrid model persistence are compared against state-based persistence on loading and saving models in terms of time and memory footprint. The results shows that, almost all cases experience a slight slowdown on loading and saving time (hybrid approach's $mean$ $>$ state-based approach's $mean$). However, almost for all hybrid NeoEMF cases, the slowdown is not significant, which means that side-effect of the hybrid approach on loading and saving time is still acceptable. 
  
  The hybrid approach also produces more memory footprint compared to the state-based-only approach. Nevertheless, considering the cost of main memory, this condition is acceptable in almost all real-world scenarios. In terms of storage space usage, in average, persisting one change event only consumes around 100 bytes. This can be used to estimate the growth of storage space usage. For example, persisting 100 million change events consumes around 10 GBs, which of course compressing this persistence can also be another topic for research.  
  
  \item \textbf{How to identify differences between two versions of a change-based model? To what extent does change-based model differencing perform, in terms of speed and memory footprint, compared to state-based model differencing? (RQ2)} 
  
 This research question is addressed in Chapter \ref{ch:model_differencing}.  This work has presented an approach to model differencing by exploiting the nature of change-based persistence which allows us to find differences between versions of a model by only comparing the last set of changes between the two versions.
 
 The change-based model differencing consists of three phases: event loading, element tree construction, and diff computation. In the event loading phase, the implementation loads change events recorded in two change-based model persistence files into memory starting from the line their change events are different. The information contained in the loaded change events are used to construct an element three. An element three essentially is the partial states -- only the affected elements and features -- of the two versions being compared including the shared original version. It is possible since change events are designed to contain adequate information to construct the element three. A model computation is then executed to identify the differences using a set of predefined rules (i.e., if an element is created in one of the versions it means that the element does not exists in the other version as well as in the original version).

 The evaluation results suggest that the the proposed change-based model differencing executes faster than traditional, state-based model differencing.
 However, the change-based model differencing needs to load change events from a change-based persistence into main memory and thus may requires more memory than for state-based state-based model differencing. In our evaluation, this occurs when the number of change events exceeds 400,000 (around 40 MBs appended change events; not the total size). Arguably, diff and merge operations are usually performed on smaller deltas than this work's evaluation.
  
  \item \textbf{How to detect conflicts between two versions of a change-based model? To what extent does change-based model conflict detection perform, in terms of speed and memory, compared to state-based model conflict detection? (RQ3)} 
  
  This research question is addressed in Chapter \ref{ch:conflict_detection}.  Similar to change-based model differencing in the previous research question (RQ2), this work also has proposed an approach to model conflict detection by exploiting the nature of change-based persistence which allows us to detect conflict between versions of a model by only comparing the eventual states of elements and features between the two versions as well as the original version that are affected by the change events.
  
  The phases in the change-based conflict detection is similar to the phases in the change-based model differencing except that the diff computation is replaced with conflict computation. It also consists of a set of rules that compares the eventual states of the elements and features in the element tree as well as the number of change events that affects them in both versions. Asn example, a feature that is modified only in one version cannot have conflicts. A conflict only occurs if the feature is modified on both versions. Also since the the element tree also records every change event to the elements of features that it affect, we can trace change events that cause a conflict.
  
Based on the findings in the conflict detection evaluation, this work found that the proposed change-based model conflict detection approach outperforms the conflict detection approaches in EMF Compare and EMF Store. Nevertheless, models that have been excessively modified or experience significant reduction on model size could impair the performance of the conflict detection as a great number of change records have to be read and loaded into memory.
  
\end{enumerate}

Based on the answers of the three research questions, this work can finally confirms the hypothesis that, 
\textbf{``Change-based model persistence reduces the execution time of model differencing and conflict detection of large models compared to their execution time in state-based model persistence, with acceptable trade-offs on loading and persisting time, memory footprint, and storage space consumption''}. However, this work is not free from limitations and threats to validity. They are presented in Section \ref{sec:limitation_and_Threat_to_validity}.

\section{Limitations and Validity}
\label{sec:limitation_and_Threat_to_validity}
This work has only tested the proposed algorithms on synthesised models which were reversed engineered from two real-world software projects Epsilon \cite{eclipse2018epsilongit} and BPMN2 \cite{eclipse2018bpmn2git}, and a collaborative content project, the article of US on Wikipedia \cite{wikipedia2018us}. The generated models may not be representative of the complexity and interconnectedness of models in other domains. Diverse characteristics of models in different domains can affect the effectiveness of the algorithm and therefore yield different outcomes. Moreover, the generated models from the reverse engineering are limited to the UML2 \cite{eclipse2017uml2}, Modisco Java \cite{eclipse2018modiscojava}, and Modisco XML \cite{eclipse2018modiscoxml} metamodels only. Thus, there is no guarantee it will perform in a consistent manner on models conforming to different metamodels.

Specifically in Chapter \ref{ch:optimised_loading}, the proposed loading optimisation of change-based model persistence only supports ordered and unique features. Support for duplicate values means that removal of an item does not necessarily result in the item not being present in the feature value. Additional information must be captured to persist the number of copies and positions of the feature members to properly generate the ignore list. 

For the proposed change-based model differencing and conflict detection in Chapters \ref{ch:model_differencing} and \ref{ch:conflict_detection}, this work has tried to cover as much as common changes made in EMF models (e.g. performing \textsf{add}/\textsf{remove}/\textsf{set}/\textsf{move} operations on \textsf{single}/\textsf{multi}-\textsf{valued} features, \textsf{attribute}/\textsf{reference} features, or \textsf{containment}/\textsf{non}-\textsf{containment} references), the random modification made in the evaluation does not largely reflect the evolution of models in the real world. This is challenging as different domains can have their own patterns of model evolution -- different problems, metamodels, modellers, etc. So far, the most complex composite changes applied to the random modification are limited to \textsf{move} and \textsf{delete} changes only (\textsf{move} event consists of \textsf{remove} and {add} events, while \textsf{delete} event also removes the sub-elements of the deleted element). More complex composite changes, such as refactoring has not been evaluated. Also, the random modification does not consider the correctness of the changes since it might certain constraints of the models. For example, in Java \cite{eclipse2018modiscojava} models, removing a parameter from a function causes errors in the function's body but are ignored in the evaluation.  

\section{Future Work}
\label{future_work}
The proposed change-based model persistence also comes with a number of challenges that this research needs to overcome, such as loading overhead and fast-growing model files. The loading overhead has been addressed in this work by introducing hybrid model persistence -- using state and change-based persistence side-by-side -- in which models are loaded from its state-based persistence. Nevertheless, the proposed approach still needs to load change events in order to construct an \textsf{elementTree} -- Section \ref{sec:tree_construction} -- to perform model differencing and conflict detection, as discussed in Chapters \ref{ch:model_differencing} and \ref{ch:conflict_detection}. The loading can be further optimised to consume less memory and speed up parsing, such as using binary or optimised-text format.

The fast-growing model files challenge has not been addressed in this work. Persisting models in a change-based format means that model files will keep growing in size during their evolution significantly faster than their state-based counterparts. This work proposes two solutions to address the issue: (1) sound change-compression operations (e.g. remove older/unused information) that can be used to reduce the size of a model in a controlled way, (2) a compact textual format that will minimise the amount of space required to record a change (a textual line-separated format is desirable to maintain compatibility with file-based version control systems). 

The information contained in change-based model persistence is also useful for Model Analytics. With appropriate tool support, modellers will be able to ``replay" (part of) the change history of a model (e.g. to understand design decisions made by other developers, for training purposes). In state-based approaches, this can be partly achieved if models are stored in a version-control repository (e.g. Git). However, the granularity would only be at the commit level. By analysing models serialised in the proposed representation, modelling language and tool vendors will be able to develop deeper insights into how modellers actually use these languages/tools in practice and utilise this information to guide the evolution of the language/tool. By attaching additional information to each session (e.g. the id of the developer, references to external documents/URLs), sequences of changes can be traced back to the developer that made them, or to requirements/bug reports that triggered them.

In the future, once the plugin of change-based model persistence has been established, this work intends to evaluate it against state-based model persistence on real-world scenario and complex models.

