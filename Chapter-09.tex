\chapter{Conclusions and Future Work}
\label{ch:conclusions_and_future_work}

This chapter summarises the research that we have conducted and the results gained from the evaluation. It starts with conclusions that answer the research questions and hypothesis proposed in Section \ref{sec:research_questions}. It then presents the limitations and threats to the validity of this research and some topics for future work. Finally, this chapter presents the big picture of this research’s contribution to other parts of model-driven engineering, such as model transformation, validation, and evolution.

\section{Conclusions}
\label{conclusions_overall}
\begin{enumerate}
  \item \textbf{How can models be persisted in a change-based format, and how does change-based persistence perform, compared to state-based persistence, in terms of loading and saving models? (RQ1)}
  
  This research question is addressed in Chapters \ref{ch:change_based_model_persistence}, \ref{ch:optimised_loading}, and \ref{ch:hybrid_model_persistence}. To persist models in change-based format, a prototype was developed. It captures relevant notifications produced by the notification facilities provided by EMF every time a change is applied to an EMF model. It then transforms the notifications into different classes of change events representing different types of changes (e.g., set, unset, add, remove, move, create, and delete) that conform to the model and meta-model infrastructure of EMF. Every captured change event is then persisted by appending it to an XML-like-formatted file when the model is saved. The model can be (re)loaded by de-serialising the file and (re)executing all the persisted change events—replaying the historical construction of the model.
  
  Since change-based models come with a drawback that their changes must be replayed in order to load them, this work investigated two approaches to improve loading. The first approach optimises loading by not replaying change events that are superseded by subsequent change events. This approach employs a tree-based data structure that tracks all changes made to a model and calculates all superseded events identified by their line numbers. These line numbers are also persisted into another file—\textsf{ignoreList} file—when the model is saved. So, once the change-based model is reloaded, the loading algorithm already knows which change events—which line numbers—should be skipped. This approach can significantly reduce the loading time of change-based models compared to non-optimised loading. However, it is still greatly outperformed by loading models from their state-based persistence, and it suffers greatly in terms of the memory footprint because of the dedicated data structure used to track change events.
  
  In contrast, saving models in change-based persistence shows more favourable results than saving models in state-based persistence, since we need to persist only recent changes in a model rather than saving the entire model. This is very favourable when working with large models at a mature stage where only small changes occur.
  
  Since the results of the first approach are not satisfying, this work also proposed hybrid model persistence—employing change and state-based persistence together. In this type of persistence, models are loaded from their state-based persistence but changes are persisted into both change and state-based persistence.
  
  In the evaluation, the effects of hybrid model persistence were compared against state-based persistence on loading and saving models in terms of time and memory footprint. The results show that almost all cases experience a slight slowdown on loading and saving time (hybrid approach’s $mean$ $>$ state-based approach’s $mean$). However, for almost all hybrid NeoEMF cases, the slowdown is not significant.
  
  The hybrid approach also produces more memory footprint than the state-based-only approach. In terms of storage space usage, on average, persisting one change event consumes only around 100 bytes. This can be used to estimate the growth of storage space usage. For example, persisting 100 million change events consumes around 10 GB.
  
  \item \textbf{In a changed-based format, how can the differences between models be identified, and how does change-based model differencing perform, in terms of speed and memory footprint, compared to state-based model differencing? (RQ2)}
  
  This research question is addressed in Chapter \ref{ch:model_differencing}. Change-based persistence can be used to identify differences between two versions of a model. The change-based representation of the two versions contains all the information needed to identify elements that have been modified since their last shared version. In this way, we can localise model differencing to the elements that have been recently modified. In other words, it is not necessary to inspect,  match, and diff all the elements. We can use the information to reconstruct the partial states of the two versions and then compare their elements and features using specific rules to identify their differences.
  
  The change-based model differencing proposed in this research consists of three phases: event loading, element tree construction, and diff computation. In the event loading phase, the implementation loads change events recorded in two change-based model persistence files into memory starting from the line their change events are different. The information that the loaded change events contains are used to construct an element tree. An element tree essentially is the partial states—only the affected elements and features—of the two versions being compared including the shared original version. It is possible to construct such a partial representation since change events are designed to contain adequate information to construct the element tree. A diff computation is then executed to identify the differences using a set of pre-defined rules (i.e., if an element is created in one version it means that the element does not exist in the other version or in the original version).
  
  The evaluation suggest that the proposed change-based model differencing executes faster than traditional, state-based model differencing.
  However, change-based model differencing needs to load change events from a change-based persistence into main memory. Thus, it can require more memory than for state-based model differencing. In our evaluation, this occurs when the number of change events exceeds 400,000. However, it is likely that diff and merge operations are performed on lower numbers of changes (smaller deltas) than were tested in this evaluation.
  
  \item \textbf{Following change-based model differencing, how can conflicts be detected between versions of a model, and how does change-based conflict detection perform, in terms of speed and memory, compared to state-based model conflict detection? (RQ3)}
  
  This research question is addressed in Chapter \ref{ch:conflict_detection}. Similar to change-based model differencing in the previous research question (RQ2), this work also proposed an approach to model conflict detection by exploiting the nature of change-based persistence. This allows us to detect conflicts between two versions of a model by comparing only the eventual states of elements and features of the two versions, including their shared original version, that are affected by change events.
  
  The phases in change-based conflict detection are similar to the phases (event loading, element tree construction, and diff computation) in change-based model differencing except that the diff computation is replaced with conflict computation. It also consists of a set of rules that compare the eventual states of the elements and features in the element tree as well as the number of change events that affects them in both versions. As an example, a feature that is modified in only one version cannot have conflicts. A conflict occurs only if the feature is modified in both versions. Also, since the element tree also records every change event to the elements of features that it affects, we can trace change events that cause a conflict.
  
  Based on the findings in the conflict detection evaluation, this work found that the proposed change-based model conflict detection approach outperforms the conflict detection approaches in EMF Compare and EMF Store. Nevertheless, models that have been excessively modified or that experience a significant reduction in model size could impair the performance of the conflict detection because a great number of change records must be read and loaded into memory.
  
\end{enumerate}

Based on the answers to the three research questions, this work can finally confirm the hypothesis that,
\textbf{‘a textual change-based model persistence approach can outperform existing model persistence formats in terms of model saving, model differencing, and conflict detection time, with an overhead in terms of model loading time and memory use’}. However, this work is not free from limitations and threats to validity. These are presented next .

\section{Limitations and Validity}
\label{sec:limitation_and_Threat_to_validity}
This work has tested the proposed algorithms only on synthesised models which were reverse-engineered from two real-world software projects Epsilon \cite{eclipse2018epsilongit} and BPMN2 \cite{eclipse2018bpmn2git}, and a collaboratively developed artefact with a long development history, the article on the United States in Wikipedia \cite{wikipedia2018us}. The generated models mmight not be representative of the complexity and interconnectedness of models in other domains. Diverse characteristics of models in different domains can affect the effectiveness of the algorithms and therefore yield different outcomes. Moreover, the generated models from the reverse engineering are limited to the UML2 \cite{eclipse2017uml2}, Modisco Java \cite{eclipse2018modiscojava}, and Modisco XML \cite{eclipse2018modiscoxml} meta-models only. Thus, there is no guarantee the algorithms will perform consistently on models that conform to different meta-models.

Specifically in Chapter \ref{ch:optimised_loading}, the proposed loading optimisation of change-based model persistence supports only ordered and unique features. Support for duplicate values means that removing an item does not necessarily result in the item not being present in the feature value. Additional information must be captured to persist the number of copies and positions of the feature members to generate the ignore list.

For the proposed change-based model differencing and conflict detection in Chapters \ref{ch:model_differencing} and \ref{ch:conflict_detection}, this work tried to cover many of the common changes made in EMF models (e.g. performing \textsf{add}/\textsf{remove}/\textsf{set}/\textsf{move} operations on \textsf{single}/\textsf{multi}-\textsf{valued} features, \textsf{attribute}/\textsf{reference} features, or \textsf{containment}/\textsf{non}-\textsf{containment} references). However, the random modification made in the evaluation might not reflect the evolution of models in the real world. This is challenging as different domains can have their own patterns of model evolution, such as different problems, meta-models, and modellers. So far, the most complex composite changes applied to the random modification are limited to \textsf{move} and \textsf{delete} changes. (A \textsf{move} event consists of \textsf{remove} and {add} events, while \textsf{delete} event also removes the sub-elements of the deleted element.) More complex composite changes, such as refactoring, have not been evaluated. Also, the random modification does not consider the correctness of the changes since it might validate certain constraints of the models. For example, in Java \cite{eclipse2018modiscojava} models, removing a parameter from a function causes errors in the function’s body, but it is ignored in the evaluation.

\section{Future Work}
\label{future_work}
The proposed change-based model persistence also comes with a number of challenges for future work, such as loading overhead and fast-growing model files. The loading overhead has been addressed in this work by introducing hybrid model persistence—using state and change-based persistence together—in which models are loaded from state-based persistence. Nevertheless, the proposed approach still requires loading change events to construct an \textsf{elementTree}—Section \ref{sec:tree_construction}—to perform model differencing and conflict detection, as discussed in Chapters \ref{ch:model_differencing} and \ref{ch:conflict_detection}. The loading can be further optimised to consume less memory and speed up parsing by using a binary or a more compact text format.

The challenge of fast-growing model files has not been addressed in this work. Persisting models in a change-based format means that the size of model files will grow significantly faster the model’s evolution than their state-based counterparts. Two approaches can be explored in the future to address the issue: (1) sound change-compression operations (e.g. remove older/unused information) to reduce the size of a model in a controlled way, (2) a compact textual format to minimise the amount of space required to record a change (a textual line-separated format is desirable to maintain compatibility with file-based version control systems).

The information contained in change-based model persistence is useful for model analytics as well. With appropriate tool support, modellers will be able to ‘replay’ (part of) the change history of a model (e.g. to understand design decisions made by other developers or for training purposes). In state-based approaches, this can be partly achieved if models are stored in a version control repository (e.g. Git). However, the granularity would be only at the commit level. By analysing models serialised in the proposed representation, modelling language and tool vendors will be able to develop deeper insights into how modellers actually use these languages/tools in practice and use that information to guide the evolution of the language/tool. By attaching additional information to each session (e.g. the ID of the developer, references to external documents/URLs), sequences of changes can be traced back to the developer that made them or to requirements/bug reports that triggered them.

\section{The Big Picture}
\label{sec:the_big_picture}

Model persistence, differencing, and conflict detection are parts of the big picture of Model-Driven Engineering. Regarding model persistence, one might consider in what scenarios change-based model persistence is preferable to state-based model persistence and \emph{vice versa}.

As our findings suggest, change-based persistence can deliver faster model differencing and conflict detection than state-based persistence. This benefit is achieved in the scenario when sizes of models are large and the number of changes is moderate compared to the size of the model. Thus, it is best to use change-based persistence in the later stages of model development when models are already large and changes are mostly for fine-tuning \cite{selic2003pragmatics}. In this way, storage overhead, because of the growing size of change-based files, can be minimised.

Change-based persistence can become unacceptable in scenarios where the number of changes is excessive relative to the size of the model. The overhead for loading and processing them to construct partial states of models can make the process slower than performing state-based model differencing or conflict detection. This happens in the early stages of model development when models are still small and changes can be numerous and radical. At these stages, state-based persistence is preferable.

The presence of change-based persistence can benefit incremental model management, such as incremental model validation and transformation. Recent changes of models can be efficiently identified without having to perform a state-based comparison to identify the differences between the current and last version of a model. In this way, we can localise model validation and transformation to elements and features that have changed only since the last version. Moreover, the produced change-based model persistence implementation conforms to the standard EMF interfaces and as such change-based models are readable/writable by EMF-compliant transformation and validation languages and engines such as ETL, EVL, OCL and ATL.

While change-based persistence is intended to record changes to models, as a model grows, its meta-model might also experience modifications. How does change-based persistence handle changes at the meta-model level? For now, we have not addressed this challenge. However, one solution that we can suggest to address this challenge is to introduce a new type of change event to be added to the existing types of change events (e.g., add, move, set, create, add, etc.). The new type of change event would indicate an upgrade/downgrade of the meta-model. Another solution is to add the version ID of the meta-model to every change event. In this way, when loading (replaying) the change events of a model, we know whether we need to do some adjustment to handle the model according to the active meta-model.

In terms of generality, one might ask, ‘can change-based model persistence, differencing, and conflict detection be applied to any modelling languages?’ As long as the modelling languages conform to the EMF meta-modelling architecture, then these operations can be applied. Nevertheless, there is no support for constraints and composite changes that are specific to a modelling language. That belongs to the future work of this research. One way to do that is by using custom adapters.

For composite changes, such as refactoring, the proposed approach also supports composite change events. This feature allows multiple changes that are part of a single refactoring activity to be put into one composite change event. Thus, a change event that conflicts with a member of a composite change event is also in conflict with the other members of the composite change event.

Still related to the generality of the solutions proposed in this research, another question to answer is ‘can the proposed change-based persistence, model differencing, and conflict detection be applied to other artefacts besides models (e.g., XML documents, spreadsheets)?’ As long as we can capture all the necessary changes to reconstruct an artefact, then it is possible. Some editors/tools already provide dedicated SDK tools to add custom functionalities. They usually provide access to some kind of event listener, which captures every event executed in the editor/tool. This functionality can be used to capture changes. Also, the format of the persisted changes also needs to be adapted, so that the persisted changes contain adequate information to reconstruct the partial states of the artefact. Once the partial states have been constructed, we can compare the elements of the partial states of the artefact.

